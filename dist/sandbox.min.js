/*! sandbox - v0.0.0 - 2014-09-19
* https://github.com/szarouski/sandbox
 Licensed http://unlicense.org/
* Description Sandbox with hierarchical support of event management
* Author Sergey Zarouski, http://webuniverse.club
*/

!function(root, factory) {
    "use strict";
    if ("function" == typeof define && define.amd) define([ "exports", "_", "simple-permissions" ], factory); else if ("object" == typeof exports) factory(exports, require("_", "simple-permissions")); else {
        var rootExports = root.exports || (root.exports = {});
        factory(rootExports.sandbox = {}, root._, root.exports.permissions);
    }
}(this, function(exports, _, simplePermissions) {
    "use strict";
    function Sandbox(name, data) {
        "string" != typeof name && (data = name, name = ""), name = getNotFalsy(name, _.uniqueId("empty"));
        var parent = getCurrentParent(), parentInfo = SandboxInfo.getFor(parent), prefix = createPrefix(parentInfo, name), childrenPrefix = prefix + "/" + _.uniqueId() + "/";
        makeSureSiblingsNamesAreUnique(prefix, name);
        var index = instanceReference.push(this) - 1;
        new SandboxInfo({
            name: name,
            prefix: prefix,
            childrenPrefix: childrenPrefix,
            parentInfo: parentInfo,
            data: data
        }).mapTo(index), new PrivateData().mapTo(prefix);
    }
    function getCurrentParent() {
        var currentParent = tempParent || root || null;
        return tempParent = null, currentParent;
    }
    function setCurrentParent(parent) {
        privateCodeTypeValidation(parent, isSandbox, "parent should be an instance of Sandbox"), 
        tempParent = parent;
    }
    function SandboxInfo(params) {
        privateCodeTypeValidation(params, function(value) {
            return _.isObject(value) && _.isString(value.name) && _.isString(value.prefix) && _.isString(value.childrenPrefix);
        }, "check signature {name: String, prefix: String, childrenPrefix: string}");
        var parentPrefix, sandboxPrefix = params.prefix, parentInfo = params.parentInfo;
        root ? (parentPrefix = parentInfo.prefix, this.siblingPrefixRegExp = new RegExp(parentInfo.childrenPrefix + "[^/]*$")) : (parentPrefix = null, 
        this.siblingPrefixRegExp = null), this.name = params.name, this.prefix = sandboxPrefix, 
        this.parentPrefix = parentPrefix, this.childrenPrefix = params.childrenPrefix, this.parentInfo = parentInfo, 
        this.chindrenPrefixRegExp = new RegExp(sandboxPrefix + ".+"), this.settings = _.cloneDeep(defaultSettings), 
        this.data = params.data;
    }
    function makeSureSiblingsNamesAreUnique(prefix, name) {
        if (privateCodeTypeValidation(prefix, _.isString, "prefix should be a string"), 
        privateCodeTypeValidation(name, _.isString, "name should be a string"), prefix in privateDataStorage) throw new SandboxError([ "Siblings can't have same names. ", name, " already exists." ].join(""));
    }
    function PrivateData() {
        this.listeners = [], this.cache = [], this.permissions = [];
    }
    function SandboxListener(params) {
        this.event = params.event, this.handler = params.handler, this.binding = params.binding, 
        this.prefix = params.prefix;
    }
    function CandidatesData() {
        this.storage = {};
    }
    function CachedEvent(params) {
        this.origin = params.origin, this.event = params.event, this.data = params.data, 
        this.invalidate = params.invalidate, this.settings = params.settings;
    }
    function SandboxError(message) {
        this.message = message;
    }
    function permitIsValid(sourcePrefix, permit, candidateData, candidatePrefix) {
        var allowEverythingForSource = candidatePrefix === sourcePrefix;
        return allowEverythingForSource || hasPermitByPrefixes(candidateData.permissions, permit, sourcePrefix, candidatePrefix);
    }
    function hasPermitByPrefixes(source, permit, sourcePrefix, candidatePrefix) {
        var permissionsMapForPrefix = _.find(source, function(entry) {
            return sourcePrefix === entry.source && candidatePrefix === entry.target;
        });
        return !(!permissionsMapForPrefix || !~_.indexOf(permissionsMapForPrefix.permissions, permit));
    }
    function forValidPermissions(candidates, validator, callback) {
        _.each(candidates.storage, function() {
            var args = _.toArray(arguments);
            validator.apply(candidates, args) && callback.apply(candidates, args);
        });
    }
    function ensureIsArray(param) {
        return _.isArray(param) ? param : [ param ];
    }
    function createPrefix(parentData, name) {
        return root ? parentData.childrenPrefix + name : rootName;
    }
    function keysToPrefixes(obj, info, sandbox) {
        var keys = _.map(obj, function(value, key) {
            return getPrefixForName(key, info, sandbox);
        }), values = _.values(obj);
        return _.object(keys, values);
    }
    function getPrefixForName(target, info, sandbox) {
        var sandboxName = sandbox.name();
        return target && target !== sandboxName ? nameToPrefix(target, info) : nameToPrefix(sandboxName, info.parentInfo);
    }
    function nameToPrefix(to, info) {
        return _.isArray(to) ? _.map(to, function(target) {
            return info.childrenPrefix + target;
        }) : [ info.childrenPrefix + to ];
    }
    function getNotFalsy(initialValue, fallbackValue) {
        return initialValue || fallbackValue;
    }
    function makeSimpleObject(key, value) {
        var obj = {};
        return obj[key] = value, obj;
    }
    function isSandbox(value) {
        return value instanceof Sandbox;
    }
    function isCachedEvent(value) {
        return value instanceof CachedEvent;
    }
    Sandbox.prototype.name = function() {
        return SandboxInfo.getFor(this).name;
    }, Sandbox.prototype.settings = function(settings) {
        validateTypes(settings, _.isObject, "settings should be an object");
        var info = SandboxInfo.getFor(this);
        info.settings = _.merge(info.settings, settings);
    }, Sandbox.prototype.kid = function() {
        setCurrentParent(this);
        var Factory = _.partial.apply(_, [ Sandbox ].concat(_.toArray(arguments)));
        return new Factory();
    }, Sandbox.prototype.data = function() {
        var data = SandboxInfo.getFor(this).data;
        return _.isObject(data) ? _.create(data) : data;
    }, Sandbox.prototype.on = function(eventName, handler, thisBinding) {
        validateTypes(eventName, _.isString, "eventName should be a string"), validateTypes(handler, _.isFunction, "handler should be a function");
        var that = this, info = SandboxInfo.getFor(that), thisPrefix = info.prefix, candidates = new CandidatesData();
        candidates.addBy([ info.parentPrefix, [ info.siblingPrefixRegExp, info.chindrenPrefixRegExp ] ]);
        var listener = new SandboxListener({
            event: eventName,
            handler: handler,
            binding: getNotFalsy(thisBinding, that),
            prefix: thisPrefix
        }), privateData = PrivateData.getFor(thisPrefix);
        return privateData.addListener(listener), forValidPermissions(candidates, _.partial(permitIsValid, thisPrefix, eventName), _.partial(SandboxListener.process, listener)), 
        that;
    }, Sandbox.prototype.off = function(eventName) {
        validateTypes(eventName, _.isString, "eventName should be a string");
        var that = this, info = SandboxInfo.getFor(that), privateData = PrivateData.getFor(info.prefix);
        return _.remove(privateData.listeners, function(listener) {
            return listener.event === eventName;
        }), this;
    }, Sandbox.prototype.emit = function(eventName, data) {
        validateTypes(eventName, _.isString, "eventName should be a string");
        var that = this, info = SandboxInfo.getFor(that), cachedEvent = new CachedEvent({
            origin: info.prefix,
            event: eventName,
            data: data,
            invalidate: !1,
            settings: info.settings.cache
        }), candidates = new CandidatesData();
        return candidates.addBy([ info.parentPrefix, [ info.siblingPrefixRegExp, info.chindrenPrefixRegExp ] ]), 
        forValidPermissions(candidates, _.partial(permitIsValid, info.prefix, eventName), _.partial(CachedEvent.process, cachedEvent)), 
        that;
    }, Sandbox.prototype.trigger = Sandbox.prototype.emit;
    var updatePermissions = function(target, permissionsMap, updater) {
        2 === arguments.length && (updater = permissionsMap, permissionsMap = target, target = void 0), 
        validateTypes(permissionsMap, _.isObject, "permissionsMap should be an object"), 
        validateTypes(updater, _.isFunction, "updater should be a function");
        var that = this, info = SandboxInfo.getFor(that), candidates = CandidatesData.getCandidatesForPermissions(that, target);
        return permissionsMap = keysToPrefixes(permissionsMap, info, that), CandidatesData.updatePermissions(updater, candidates, permissionsMap), 
        that;
    };
    Sandbox.prototype.grant = _.partialRight(updatePermissions, function(data, prefix, permissionsMap) {
        privateCodeTypeValidation(permissionsMap, _.isObject, "permissionsMap should be an object"), 
        simplePermissions.grant(data.permissions, prefix, permissionsMap);
    }), Sandbox.prototype.revoke = _.partialRight(updatePermissions, function(data, prefix, permissionsMap) {
        privateCodeTypeValidation(permissionsMap, _.isObject, "permissionsMap should be an object"), 
        simplePermissions.revoke(data.permissions, prefix, permissionsMap), _.remove(data.cache, function(cachedEvent) {
            return cachedEvent.origin in permissionsMap && ~_.indexOf(permissionsMap[cachedEvent.origin], cachedEvent.event);
        });
    }), Sandbox.prototype.destroy = function() {
        var info = SandboxInfo.getFor(this), privateData = PrivateData.getFor(info.prefix), index = _.indexOf(instanceReference, this);
        instanceReference.splice(index, 1), info.unMapFrom(index), privateData.unMapFrom(info.prefix);
    };
    var defaultSettings = {
        cache: {
            store: !0,
            expire: 0,
            debounce: !0
        }
    };
    Sandbox.defaults = function(newDefaults) {
        return newDefaults && _.merge(defaultSettings, newDefaults), defaultSettings;
    };
    var tempParent = null, instanceReference = [], sandboxInfoStorage = [];
    SandboxInfo.prototype.mapTo = function(index) {
        privateCodeTypeValidation(index, _.isNumber, "index should be a number"), sandboxInfoStorage[index] = this;
    }, SandboxInfo.prototype.unMapFrom = function(index) {
        privateCodeTypeValidation(index, _.isNumber, "index should be a number"), sandboxInfoStorage.splice(index, 1);
    }, SandboxInfo.getFor = function(sandbox) {
        return sandbox ? sandboxInfoStorage[_.indexOf(instanceReference, sandbox)] : null;
    };
    var privateDataStorage = {};
    PrivateData.prototype.mapTo = function(prefix) {
        privateCodeTypeValidation(prefix, _.isString, "prefix should be a string"), privateDataStorage[prefix] = this;
    }, PrivateData.prototype.unMapFrom = function(prefix) {
        privateCodeTypeValidation(prefix, _.isString, "prefix should be a string"), delete privateDataStorage[prefix];
    }, PrivateData.prototype.addToCache = function(event) {
        privateCodeTypeValidation(event, isCachedEvent, "event should be an instance of CachedEvent"), 
        this.cache.push(event), event.settings.expire && event.setupExpirationFor(this);
    }, PrivateData.prototype.addListener = function(listenerInfo) {
        this.listeners.push(listenerInfo);
    }, PrivateData.prototype.processEvent = function(event) {
        var listeners = event.filterEventListeners(this.listeners), storeInCache = event.settings.store && !listeners.length;
        SandboxListener.callEventListeners(listeners, event), storeInCache && this.addToCache(event);
    }, PrivateData.getFor = function(prefix) {
        return privateDataStorage[prefix];
    }, PrivateData.getWrappedBy = function(prefix) {
        return makeSimpleObject(prefix, PrivateData.getFor(prefix));
    }, PrivateData.getByRegExp = function(regExpOrArray) {
        var regExes = ensureIsArray(regExpOrArray);
        return _.pick(privateDataStorage, function(data, prefix) {
            return _.some(regExes, function(regExp) {
                return regExp.test(prefix);
            });
        });
    }, SandboxListener.process = function(listener, candidateData) {
        var storedCandidates = this, privateData = storedCandidates.getFor(listener.prefix), candidateCachedEvents = _.filter(candidateData.cache, {
            event: listener.event
        });
        _.each(candidateCachedEvents, _.partial(SandboxListener.callEventListeners, privateData.listeners));
    }, SandboxListener.callEventListeners = function(listeners, event) {
        _.each(listeners, function(listener) {
            listener.handler.apply(listener.binding, ensureIsArray(event.data)), event.updateExpiration();
        });
    }, CandidatesData.prototype.addBy = function(prefixes) {
        var that = this;
        return _.each(prefixes, function(prefix) {
            var data;
            data = "string" == typeof prefix ? PrivateData.getWrappedBy(prefix) : PrivateData.getByRegExp(prefix), 
            _.extend(that.storage, data);
        }), that;
    }, CandidatesData.prototype.getFor = function(prefix) {
        return this.storage[prefix];
    }, CandidatesData.prototype.getFilteredByPrefix = function(prefixes) {
        return _.pick(this.storage, function(candidateData, candidatePrefix) {
            return ~_.indexOf(prefixes, candidatePrefix);
        });
    }, CandidatesData.getCandidatesForPermissions = function(sandbox, target) {
        var info = SandboxInfo.getFor(sandbox), candidates = new CandidatesData();
        return candidates.addBy([ info.prefix, info.chindrenPrefixRegExp ]), target = getPrefixForName(target, info, sandbox), 
        candidates.getFilteredByPrefix(target);
    }, CandidatesData.updatePermissions = function(updater, candidates, permissionsMap) {
        _.each(candidates, function(data, prefix) {
            updater(data, prefix, permissionsMap);
        });
    }, CachedEvent.prototype.filterEventListeners = function(listeners) {
        return _.filter(listeners, {
            event: this.event
        });
    }, CachedEvent.prototype.updateExpiration = function() {
        "function" == typeof this.invalidate && this.invalidate();
    }, CachedEvent.prototype.setupExpirationFor = function(candidateData) {
        function removeEventFromCache() {
            cachedEvent.removeFrom(candidateData.cache);
        }
        var cachedEvent = this, cacheSettings = cachedEvent.settings;
        cacheSettings.debounce ? (cachedEvent.invalidate = _.debounce(removeEventFromCache, cacheSettings.expire), 
        cachedEvent.invalidate()) : _.delay(removeEventFromCache, cacheSettings.expire);
    }, CachedEvent.prototype.removeFrom = function(cache) {
        var index = _.findIndex(cache, this);
        ~index && cache.splice(index, 1);
    }, CachedEvent.process = function(event, candidateData) {
        candidateData.processEvent(event);
    }, SandboxError.prototype = new Error(), SandboxError.prototype.constructor = SandboxError;
    var validateTypes = function(value, validator, errorMessage) {
        if (!validator(value)) throw new SandboxError(errorMessage + ", received type: " + typeof value);
    }, privateCodeTypeValidation = function() {}, rootName = "√", root = new Sandbox(rootName);
    exports.Sandbox = Sandbox, exports.SandboxError = SandboxError;
});